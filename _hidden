#!/usr/bin/python

import os
import readline
import sys
import termios
import xml.etree.ElementTree as ET
import datetime
import signal
import ConfigParser


######
# need move to config file
######
PROMPT = "hidden>"
TIMEOUT_PASSWD = 10
CMD_SPECIAL_CHAR = "-_|/. "
CMD_MAX_LEN = 128
HISTORY_MAX = 10

####
# global variable
####
INI_FILE = "./hidden.ini"
INI_SECTION_CMDFILE = "cmdfile"
INI_OPTION_CMDFILE = "cmd_help_file"
INI_SECTION_CFG = "programcfg"
INI_OPTION_PASSTIMEOUT = "input_password_timeout"
INI_OPTION_PROMPT = "prompt"
INI_OPTION_HISTORY = "history_line_max"
term_original = None
xml_root = None
######

# macro definition
#CHAR_TYPE_CTL = 1
#CHAR_TYPE_CMD = 2

#UP_ARROW    = 1
#DOWN_ARROW  = 2
#RIGHT_ARROW = 3
#LEFT_ARROW  = 4

#keyboard shortcuts
CTRL_A = 1
CTRL_E = 5
CTRL_N = 14
CTRL_P = 16
KEY_DEL = 127

def getpasswd(prompt="Password: "):
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def alarm_handler(signum, frame):
    raise KeyboardInterrupt


def user_authentication():
    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(TIMEOUT_PASSWD)
    try:
        password = getpasswd()
    except KeyboardInterrupt:
        print("Timeout")
        sys.exit()
    else:
        signal.alarm(0)
        i = datetime.datetime.now()
        if (('' == password) or (not password.isdigit()) or
           (i.year + i.month * 100 + i.day != int(password))):
            print('')
            sys.exit()
        else:
            print('')


##
## should not enable more than once
##
def term_set_canonical(enable):
    global term_original
    fd = sys.stdin.fileno()
    if  1 == enable:
        term_original = termios.tcgetattr(fd)
        new = term_original[:]
        new[3] = new[3] & ~(termios.ECHO | termios.ICANON)
        termios.tcsetattr(fd, termios.TCSADRAIN, new);
    else:
        termios.tcsetattr(fd, termios.TCSADRAIN, term_original)

#ch only 1 char
def is_cli_char(ch):
    if (ch.isalnum() or (ch in CMD_SPECIAL_CHAR)):
        return True
    return False


def exec_cli(cli):
    if cli == "quit" or cli == "exit":
        sys.exit()
    else:
        print("==> you input cli:\n" + cli)


def cmd_help_print(fdw, str):
    if len(str) == 0:
        for i in xml_root:
#            os.write(fdw, i.tag)
            if i.attrib.has_key('name'):
                os.write(fdw, i.attrib['name'].ljust(20))
            if i.attrib.has_key('help'):
                os.write(fdw, '-'+ i.attrib['help'])
            os.write(fdw, '\n')
    else:
        pass

            

def cmd_table_complete():
    pass


def run_cmd():
    fdw = sys.stdout.fileno()
    os.write(fdw, PROMPT)

    #define variable
    currline = []
    history_position = 0
    history = []
    last_position = 0  #cursor position

    while True:
#       sys.stdout.write("please input:")
#       sys.stdout.flush()

        ch = os.read(sys.stdin.fileno(), 1)

        # 1. Control key
        #if '^[' == ch:
        if ord(ch) == 27:
            ch = os.read(sys.stdin.fileno(), 1)
            #if '[' == ch:
            if ord(ch) == 91:
                ch = os.read(sys.stdin.fileno(), 1)

                # UP_ARROW
                if 'A' == ch:
                    if 0 == history_position: #no history more
                        os.write(fdw, '\a') #use bell
                    else:
                        history_position -= 1
                        os.write(fdw, '\r' + ' ' * (len(currline) + len(PROMPT)) + '\r') #cover up old line
                        os.write(fdw, PROMPT)
                        os.write(fdw, history[history_position]) #display select history line
                        currline = list(history[history_position])
                        last_position = len(currline)

                # DOWN_ARROW
                elif 'B' == ch:
                    if len(history) == history_position: #no history more
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, '\r' + ' ' * (len(currline) + len(PROMPT)) + '\r') #cover up old line
                        os.write(fdw, PROMPT)
                        os.write(fdw, history[history_position]) #display select history line
                        currline = list(history[history_position])
                        last_position = len(currline)
                        history_position += 1

                # RIGHT_ARROW
                elif 'C' == ch:
                    if len(currline) == last_position:
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, currline[last_position])
                        last_position += 1

                # LEFT_ARROW
                elif 'D' == ch:
                    if 0 == last_position:  #no left more.
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, '\b')
                        last_position -= 1

                # other ctl key ignore
                else:
                    os.write(fdw, '\a') #use bell
        # 2. Entry
        elif '\n' == ch:
            os.write(fdw, '\n')

            #record to history, except empty line.
            if len(currline) != 0:
                history.append(''.join(currline))
                history_position = len(history)

                #clear old history record line
                if len(history) == HISTORY_MAX:
                    del(history[0])
                    history_position -= 1

                #clear currline char
                currline = []
                last_position = 0

                #execute cli program
                exec_cli(history[history_position-1].strip())

            #echo prompt
            os.write(fdw, PROMPT)

        # 3. Help key
        elif '?' == ch:
            os.write(fdw, '?\n')
            cmd_help_print(fdw, ''.join(currline).lstrip())
            os.write(fdw, PROMPT)
            os.write(fdw, ''.join(currline))

        # 4. Table key
        elif '\t' == ch:
            cmd_table_complete()
            #fix

        # 5. Backspace
        elif '\b' == ch:
            #delete char
            if last_position > 0:
                last_position -= 1
                del(currline[last_position])

                #delete screen
                if len(currline) == last_position:
                    os.write(fdw, '\b \b')
                else:
                    os.write(fdw, '\b')
                    os.write(fdw, ''.join(currline[last_position:]))
                    os.write(fdw, ' \b') #cover up last char space
                    os.write(fdw, '\b' * len(currline[last_position:]))
            else:
                os.write(fdw, '\a') #use bell

        # 6. CLI char
        elif is_cli_char(ch):
            if len(currline) >= CMD_MAX_LEN :
                os.write(fdw, '\a') #use bell
            else:
                currline.insert(last_position, ch)
                last_position += 1

                #cursor at tail
                if len(currline) == last_position :
                    os.write(fdw, ch)
                #cursor not at tail
                else:
                    os.write(fdw, ''.join(currline[last_position-1:]))
                    os.write(fdw, '\b' * len(currline[last_position:]))

        # 7. Other char
        else:
            #keyboard shortcuts
            if ord(ch) == KEY_DEL:
                pass
            elif ord(ch) == CTRL_A:
                pass
            else:
                #ignore other char
                os.write(fdw, '\a')


def env_check():
    if os.name != 'posix':
        print("Please run this in posix OS, for example: Linux.")
        sys.exit()
    if (sys.version_info[0] != 2) or (sys.version_info[1] != 7):
        print("Program environment need 2.7, other env has not test.")
        sys.exit()


def main():
    term_set_canonical(1)
    try:
        run_cmd()
    except KeyboardInterrupt:
        return  #need ignore
    finally:
        term_set_canonical(0)


def init_config():
    global PROMPT
    global TIMEOUT_PASSWD
    global HISTORY_MAX
    global xml_root
    try:
        cfg = ConfigParser.ConfigParser()
        cfg.read(INI_FILE)
        # read config from ini file, if not exist then use default config.
        if cfg.has_section(INI_SECTION_CFG):
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_PROMPT):
                tmp = cfg.get(INI_SECTION_CFG, INI_OPTION_PROMPT)
                if len(tmp) > 0:
                    PROMPT = tmp
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_PASSTIMEOUT):
                timeo = cfg.get(INI_SECTION_CFG, INI_OPTION_PASSTIMEOUT)
                if len(timeo) > 0 and timeo.isdigit():
                    TIMEOUT_PASSWD = int(timeo)
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_HISTORY):
                h_max = cfg.get(INI_SECTION_CFG, INI_OPTION_HISTORY)
                if len(h_max) > 0 and h_max.isdigit():
                    HISTORY_MAX = int(h_max)

        # read xml command file. if not exist then means no command, so exit program.
        if cfg.has_section(INI_SECTION_CMDFILE):
            if cfg.has_option(INI_SECTION_CMDFILE, INI_OPTION_CMDFILE):
                cmdfile = cfg.get(INI_SECTION_CMDFILE, INI_OPTION_CMDFILE)
                if len(cmdfile) > 0:
                    tree = ET.parse(cmdfile)
                    xml_root = tree.getroot()
                else:
                    sys.exit()
            else:
                sys.exit()
        else:
            sys.exit()

    except Exception, e: #IOError:
        print "read config file failed."
        print str(e)
        sys.exit()


if __name__ == '__main__':
    env_check()
    user_authentication()
    init_config()
    main()


#tree = ET.parse('./keys/vm.xml')
#root = tree.getroot()

#for cmd in root:
#    print(cmd.tag, cmd.attrib)

