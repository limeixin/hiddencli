#!/usr/bin/python

import os
import readline
import sys
import termios
import xml.etree.ElementTree as ET
import datetime
import signal
import ConfigParser


######
# need move to config file
######
PROMPT = "hidden>"
TIMEOUT_PASSWD = 10
CMD_SPECIAL_CHAR = "-_|/. "
CMD_MAX_LEN = 128
HISTORY_MAX = 10

####
# global variable
####
INI_FILE = "./hidden.ini"
INI_SECTION_CMDFILE = "cmdfile"
INI_OPTION_CMDFILE = "cmd_help_file"
INI_SECTION_CFG = "programcfg"
INI_OPTION_PASSTIMEOUT = "input_password_timeout"
INI_OPTION_PROMPT = "prompt"
INI_OPTION_HISTORY = "history_line_max"
term_original = None
xml_root = None
######

# macro definition
#CHAR_TYPE_CTL = 1
#CHAR_TYPE_CMD = 2

#UP_ARROW    = 1
#DOWN_ARROW  = 2
#RIGHT_ARROW = 3
#LEFT_ARROW  = 4

#keyboard shortcuts
CTRL_A = 1
CTRL_E = 5
CTRL_N = 14
CTRL_P = 16
KEY_DEL = 127

def getpasswd(prompt="Password: "):
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    new = termios.tcgetattr(fd)
    new[3] = new[3] & ~termios.ECHO
    try:
        termios.tcsetattr(fd, termios.TCSADRAIN, new)
        passwd = raw_input(prompt)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)
    return passwd


def alarm_handler(signum, frame):
    raise KeyboardInterrupt


def user_authentication():
    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(TIMEOUT_PASSWD)
    try:
        password = getpasswd()
    except KeyboardInterrupt:
        print("Timeout")
        sys.exit()
    else:
        signal.alarm(0)
        i = datetime.datetime.now()
        if (('' == password) or (not password.isdigit()) or
           (i.year + i.month * 100 + i.day != int(password))):
            print('')
            sys.exit()
        else:
            print('')


##
## should not enable more than once
##
def term_set_canonical(enable):
    global term_original
    fd = sys.stdin.fileno()
    if  1 == enable:
        term_original = termios.tcgetattr(fd)
        new = term_original[:]
        new[3] = new[3] & ~(termios.ECHO | termios.ICANON)
        termios.tcsetattr(fd, termios.TCSADRAIN, new);
    else:
        termios.tcsetattr(fd, termios.TCSADRAIN, term_original)

#ch only 1 char
def is_cli_char(ch):
    if (ch.isalnum() or (ch in CMD_SPECIAL_CHAR)):
        return True
    return False


def exec_cli(cli):
    if cli == "quit" or cli == "exit":
        sys.exit()
    else:
        print("==> you input cli:\n" + cli)


def print_node(fdw, node):
    name = node.get('name')
    help = node.get('help')
    if name:
        os.write(fdw, name.ljust(20))
        if help:
            os.write(fdw, '-' + help)
        os.write(fdw, '\n')


def print_all_child(fdw, node):
    for i in node.getchildren():
        print_node(fdw, i)


def is_param_match(cmdkey, ptype):
    return True


def is_match(cmdkey, node):
    if node.tag == "COMMAND" and node.get('name') == cmdkey:
        return True
    if node.tag == "PARAM" and is_param_match(cmdkey, node.get('ptype')):
        return True
    return False


#callback for walk_tree
#level start from 1
g_match_nodes = []  #init it in path_tail_nodes
def match_cb(node, level, cmdlist):
    #level must start from 1, and cmdlist can not empty
    global g_match_nodes
    if is_match(cmdlist[level-1], node):
        if len(cmdlist) == level:
            g_match_nodes.append(node)
        return True
    else:
        return False

#notice: len(cmdlist) must > 0
#level must start from 1
def walk_tree(root, level, cb, cmdlist):
    children = root.getchildren()
    if len(children) == 0 or level > len(cmdlist):  
        return
    for child in children:
        if True == cb(child, level, cmdlist):
            walk_tree(child, level + 1, cb, cmdlist)
    return

def path_tail_nodes(cmdlist):
    global g_match_nodes
    g_match_nodes = []
    if 0 == len(cmdlist):
        g_match_nodes.append(xml_root)
    else:
        walk_tree(xml_root, 1, match_cb, cmdlist)
    return g_match_nodes


def cmd_help_print(fdw, str):
    if len(str) == 0:
        print_all_child(fdw, xml_root)

    elif str[-1] == ' ':
        have_action = False
        cmdlist = str.strip().split(' ')
        nodes = path_tail_nodes(cmdlist)
        for n in nodes:
#            print_all_child(fdw, n)
            for i in n.getchildren():
                print_node(fdw, i)
                if i.tag == "ACTION":
                    have_action = True
        if have_action:
            os.write(fdw, '<LF>\n')

    else:
        cmdlist = str.strip().split(' ')
        list_1 = cmdlist[:-1]
        nodes = path_tail_nodes(list_1)
        for n in nodes:
            for n_curr in n.getchildren():
                if ((n_curr.tag == "COMMAND" and n_curr.get('name').startswith(cmdlist[-1])) or 
                    (n_curr.tag == "PARAM")):
                    print_node(fdw, n_curr)


def is_match_token(token, node):
    if len(token) == 0:
        return True
    else:
        if (node.tag == "COMMAND" and (not node.get('name').startswith(token))):
            return False
        else:
            return True


def cmd_table_try_complete(fdw, str):
    nodes = []
    tns = []
    token = ''
    if len(str) == 0:
#        print_all_child(fdw, xml_root)
        return nodes

    cmdlist = str.strip().split(' ')
    if str[-1] == ' ':
        nodes = path_tail_nodes(cmdlist)
    else:
        token = cmdlist[-1]
        nodes = path_tail_nodes(cmdlist[:-1])

    for lastnode in nodes:
        for tn in lastnode.getchildren():
            if is_match_token(token, tn):
                tns.append(tn)
    return tns


def run_cmd():
    fdw = sys.stdout.fileno()
    os.write(fdw, PROMPT)

    #define variable
    currline = []
    history_position = 0
    history = []
    last_position = 0  #cursor position

    while True:
#       sys.stdout.write("please input:")
#       sys.stdout.flush()

        ch = os.read(sys.stdin.fileno(), 1)

        # 1. Control key
        #if '^[' == ch:
        if ord(ch) == 27:
            ch = os.read(sys.stdin.fileno(), 1)
            #if '[' == ch:
            if ord(ch) == 91:
                ch = os.read(sys.stdin.fileno(), 1)

                # UP_ARROW
                if 'A' == ch:
                    if 0 == history_position: #no history more
                        os.write(fdw, '\a') #use bell
                    else:
                        history_position -= 1
                        os.write(fdw, '\r' + ' ' * (len(currline) + len(PROMPT)) + '\r') #cover up old line
                        os.write(fdw, PROMPT)
                        os.write(fdw, history[history_position]) #display select history line
                        currline = list(history[history_position])
                        last_position = len(currline)

                # DOWN_ARROW
                elif 'B' == ch:
                    if len(history) == history_position: #no history more
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, '\r' + ' ' * (len(currline) + len(PROMPT)) + '\r') #cover up old line
                        os.write(fdw, PROMPT)
                        os.write(fdw, history[history_position]) #display select history line
                        currline = list(history[history_position])
                        last_position = len(currline)
                        history_position += 1

                # RIGHT_ARROW
                elif 'C' == ch:
                    if len(currline) == last_position:
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, currline[last_position])
                        last_position += 1

                # LEFT_ARROW
                elif 'D' == ch:
                    if 0 == last_position:  #no left more.
                        os.write(fdw, '\a') #use bell
                    else:
                        os.write(fdw, '\b')
                        last_position -= 1

                # other ctl key ignore
                else:
                    os.write(fdw, '\a') #use bell
        # 2. Entry
        elif '\n' == ch:
            os.write(fdw, '\n')

            #record to history, except empty line.
            if len(currline) != 0:
                history.append(''.join(currline))
                history_position = len(history)

                #clear old history record line
                if len(history) == HISTORY_MAX:
                    del(history[0])
                    history_position -= 1

                #clear currline char
                currline = []
                last_position = 0

                #execute cli program
                exec_cli(history[history_position-1].strip())

            #echo prompt
            os.write(fdw, PROMPT)

        # 3. Help key
        elif '?' == ch:
            os.write(fdw, '?\n')
            cmd_help_print(fdw, ''.join(currline).lstrip())
            os.write(fdw, PROMPT)
            os.write(fdw, ''.join(currline))

        # 4. Table key
        elif '\t' == ch:
            tns = cmd_table_try_complete(fdw, ''.join(currline).lstrip())
            tns_len = len(tns)
            if tns_len == 0:
                pass
            elif tns_len == 1 and tns[0].tag == "COMMAND":
                    tn_name = tns[0].get('name')
                    tn_name_len = len(tn_name)
                    if tn_name_len > 0:
                        if currline[-1] == ' ':
                            os.write(fdw, tn_name)
                            currline = currline[:] + list(tn_name)
                            last_position = last_position + tn_name_len
                        else:
                            tokenlist = ''.join(currline).split(' ')
                            token = tokenlist[-1]
                            tokenlen = len(token)
                            outstr = tn_name[tokenlen:]
                            if len(outstr) == 0:
                                outstr = ' '
                            os.write(fdw, outstr)
                            currline = currline[:] + list(outstr)
                            last_position = last_position + len(outstr)
                    else:
                        pass
            else:
                have_action = False
                os.write(fdw, '\n')
                for tnode in tns:
                    print_node(fdw, tnode)
                    if tnode.tag == "ACTION":
                        have_action = True
                if have_action:
                    os.write(fdw, '<LF>\n')
                os.write(fdw, PROMPT)
                os.write(fdw, ''.join(currline))

        # 5. Backspace
        elif '\b' == ch:
            #delete char
            if last_position > 0:
                last_position -= 1
                del(currline[last_position])

                #delete screen
                if len(currline) == last_position:
                    os.write(fdw, '\b \b')
                else:
                    os.write(fdw, '\b')
                    os.write(fdw, ''.join(currline[last_position:]))
                    os.write(fdw, ' \b') #cover up last char space
                    os.write(fdw, '\b' * len(currline[last_position:]))
            else:
                os.write(fdw, '\a') #use bell

        # 6. CLI char
        elif is_cli_char(ch):
            if len(currline) >= CMD_MAX_LEN :
                os.write(fdw, '\a') #use bell
            else:
                currline.insert(last_position, ch)
                last_position += 1

                #cursor at tail
                if len(currline) == last_position :
                    os.write(fdw, ch)
                #cursor not at tail
                else:
                    os.write(fdw, ''.join(currline[last_position-1:]))
                    os.write(fdw, '\b' * len(currline[last_position:]))

        # 7. Other char
        else:
            #keyboard shortcuts
            if ord(ch) == KEY_DEL:
                pass
            elif ord(ch) == CTRL_A:
                pass
            else:
                #ignore other char
                os.write(fdw, '\a')


def env_check():
    if os.name != 'posix':
        print("Please run this in posix OS, for example: Linux.")
        sys.exit()
    if (sys.version_info[0] != 2) or (sys.version_info[1] != 7):
        print("Program environment need 2.7, other env has not test.")
        sys.exit()


def main():
    term_set_canonical(1)
    try:
        run_cmd()
    except KeyboardInterrupt:
        return  #need ignore
    finally:
        term_set_canonical(0)


def init_config():
    global PROMPT
    global TIMEOUT_PASSWD
    global HISTORY_MAX
    global xml_root
    try:
        cfg = ConfigParser.ConfigParser()
        cfg.read(INI_FILE)
        # read config from ini file, if not exist then use default config.
        if cfg.has_section(INI_SECTION_CFG):
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_PROMPT):
                tmp = cfg.get(INI_SECTION_CFG, INI_OPTION_PROMPT)
                if len(tmp) > 0:
                    PROMPT = tmp
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_PASSTIMEOUT):
                timeo = cfg.get(INI_SECTION_CFG, INI_OPTION_PASSTIMEOUT)
                if len(timeo) > 0 and timeo.isdigit():
                    TIMEOUT_PASSWD = int(timeo)
            if cfg.has_option(INI_SECTION_CFG, INI_OPTION_HISTORY):
                h_max = cfg.get(INI_SECTION_CFG, INI_OPTION_HISTORY)
                if len(h_max) > 0 and h_max.isdigit():
                    HISTORY_MAX = int(h_max)

        # read xml command file. if not exist then means no command, so exit program.
        if cfg.has_section(INI_SECTION_CMDFILE):
            if cfg.has_option(INI_SECTION_CMDFILE, INI_OPTION_CMDFILE):
                cmdfile = cfg.get(INI_SECTION_CMDFILE, INI_OPTION_CMDFILE)
                if len(cmdfile) > 0:
                    tree = ET.parse(cmdfile)
                    xml_root = tree.getroot()
                else:
                    sys.exit()
            else:
                sys.exit()
        else:
            sys.exit()

    except Exception, e: #IOError:
        print "read config file failed."
        print str(e)
        sys.exit()


if __name__ == '__main__':
    env_check()
    user_authentication()
    init_config()
    main()


#tree = ET.parse('./keys/vm.xml')
#root = tree.getroot()

#for cmd in root:
#    print(cmd.tag, cmd.attrib)

